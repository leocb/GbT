local function RemoveCallback( Particle, HitPos, Normal )

	Particle:SetLifeTime( 0 )
	Particle:SetDieTime( 0 )
	
	Particle:SetStartSize( 0 )
	Particle:SetEndSize( 0 )
	
	Particle:SetStartAlpha( 0 )
	Particle:SetEndAlpha( 0 )
	
end

local function SlideCallback( Particle, HitPos, Normal )

	Particle:SetBounce( 1 )
	local Vel = Particle:GetVelocity()
	Vel.z = 0
	Particle:SetVelocity( Vel )
	Particle:SetPos(HitPos + Normal)
	
end

local function StickCallback( Particle, HitPos, Normal )

	Particle:SetAngleVelocity( Angle(0, 0, 0) )
	
	if (Particle.Align) then
		local Ang = Normal:Angle()
		Ang:RotateAroundAxis(Normal, Particle:GetAngles().y)
		Particle:SetAngles(Ang)
	end
	
	if (Particle.Stick) then
		Particle:SetVelocity( Vector( 0,0,0 ) )
		Particle:SetGravity( Vector( 0,0,0 ) )
	end
	
	Particle:SetLifeTime( 0 )
	Particle:SetDieTime( Particle.StickLifeTime )
	
	Particle:SetStartSize( Particle.StickStartSize )
	Particle:SetEndSize( Particle.StickEndSize )
	
	Particle:SetStartAlpha( Particle.StickStartAlpha )
	Particle:SetEndAlpha( Particle.StickEndAlpha )
end

function EFFECT:Init( Data )
	local Pos = Data:GetOrigin()
	local Ent = Data:GetEntity()
	local _3D = util.tobool(math.ceil(Data:GetRadius()))
	print(Data:GetRadius(), _3D)
	
	self.Emitter = ParticleEmitter( Pos, _3D)
	self.Is3D = _3D
	self.ParticleMaker = Ent
	self.Created = RealTime() + 0.1
	self.NextShot = RealTime()
end


function EFFECT:Think( )
	
	local Ent = self.ParticleMaker
	
	if (not Ent) or (not Ent:IsValid()) then 
		self.Emitter:Finish()
		
		return false
	end
	
	if (Ent:GetNetworkedBool("Activated")) then
		if (self.NextShot < RealTime()) then
			local Pos = Ent:GetPos()
			Pos = Pos + Ent:GetUp() * 4	
			
			local Ply = Ent:GetNetworkedEntity("Player")
			local Trace = Ent:GetNetworkedBool("Traceline") 
			
			local Ang
			if (Ply != NULL) and (Trace) then
				local Tr = util.QuickTrace(Ply:GetShootPos(), Ply:GetAimVector() * 99999, {Ply, Ent})
				if (Tr.Hit) then
					Pos = Tr.HitPos
					Ang = Tr.HitNormal
				end
			elseif (Ply != NULL) and (not Trace) then
				
				local ViewModel
				if (Ply == LocalPlayer()) then
					ViewModel = Ply:GetViewModel()
					Pos = ViewModel:GetAttachment(1).Pos
				else
					ViewModel = Ply:GetActiveWeapon()
					Pos = ViewModel:GetAttachment(1).Pos
				end
				
				Ang = Ply:GetAimVector()
			else
				Ang = Ent:GetUp()
			end
			
			local Velocity 		= Ent:GetNetworkedFloat("Velocity")
			local Spread 		= Ent:GetNetworkedFloat("Spread") / 180
			local Number 		= Ent:GetNetworkedInt("Number")
			local DieTime 		= Ent:GetNetworkedFloat("DieTime")
			local StartAlpha 	= Ent:GetNetworkedFloat("StartAlpha")
			local EndAlpha 		= Ent:GetNetworkedFloat("EndAlpha")
			local StartSize 	= Ent:GetNetworkedFloat("StartSize")
			local EndSize 		= Ent:GetNetworkedFloat("EndSize")
			local StartLength 	= Ent:GetNetworkedFloat("StartLength")
			local EndLength 	= Ent:GetNetworkedFloat("EndLength")
			local Roll 			= Ent:GetNetworkedFloat("Roll")
			local RollDelta 	= Ent:GetNetworkedFloat("RollDelta")
			local AirResistance	= Ent:GetNetworkedFloat("AirResistance")
			local Bounce		= Ent:GetNetworkedFloat("Bounce")
			local Gravity		= Ent:GetNetworkedFloat("Gravity")
			local Collide		= Ent:GetNetworkedBool("Collide")
			local Lighting		= Ent:GetNetworkedBool("Lighting")
			local Sliding		= Ent:GetNetworkedBool("Sliding")
			local R1			= Ent:GetNetworkedInt("R1")
			local G1			= Ent:GetNetworkedInt("G1")
			local B1			= Ent:GetNetworkedInt("B1")
			local R2			= Ent:GetNetworkedInt("R2")
			local G2			= Ent:GetNetworkedInt("G2")
			local B2			= Ent:GetNetworkedInt("B2")
			local Random		= Ent:GetNetworkedBool("Random")
			local Material		= Ent:GetNetworkedString("Material")
			
			local _3D				= self.Is3D
			local Align				= Ent:GetNetworkedBool("Align")
			local Stick				= Ent:GetNetworkedBool("Stick")
			local DoubleSided		= Ent:GetNetworkedBool("DoubleSided")
			local AngleVelX			= Ent:GetNetworkedFloat("AngleVelX")
			local AngleVelY			= Ent:GetNetworkedFloat("AngleVelY")
			local AngleVelZ			= Ent:GetNetworkedFloat("AngleVelZ")
			local StickLifeTime		= Ent:GetNetworkedFloat("StickLifeTime")
			local StickStartSize	= Ent:GetNetworkedFloat("StickStartSize")
			local StickEndSize		= Ent:GetNetworkedFloat("StickEndSize")
			local StickStartAlpha	= Ent:GetNetworkedFloat("StickStartAlpha")
			local StickEndAlpha		= Ent:GetNetworkedFloat("StickEndAlpha")
			
			local Double = 1
			if (DoubleSided) then
				Double = 2
			end
			
			for _=1, Number do
			
				local Vec = Vector() * 0
				if (Spread != 0) then
					Vec = Vector(math.sin(math.random()) * math.Rand(-Spread, Spread), math.sin(math.random()) * math.Rand(-Spread, Spread), math.sin(math.random()) * math.Rand(-Spread, Spread))
				end
				local RandColor
				if (Random) then
					RandColor = {math.random(math.min(R1, R2), math.max(R1, R2)), math.random(math.min(G1, G2), math.max(G1, G2)), math.random(math.min(B1, B2), math.max(B1, B2))}
				else
					RandColor = {R1, G1, B1}
				end
				
				local RandRoll = math.Rand(-Roll, Roll)
				
				for i=1, Double do
					local P = self.Emitter:Add(Material, Pos)
					
					if (DoubleSided) then
						local Angl
						if (i == 1) then
							Angl = (Ang * -1):Angle()
						elseif (i == 2) then
							Angl = Ang:Angle()
						end
						P:SetAngles( Angl )
					else
						P:SetAngles( Ang:Angle() )
					end
					
					P:SetVelocity( (Vec + Ang) * Velocity )
					P:SetColor(unpack(RandColor))
					P:SetDieTime( DieTime )
					P:SetStartAlpha( StartAlpha )
					P:SetEndAlpha( EndAlpha )
					P:SetStartSize( StartSize )
					P:SetEndSize( EndSize )
					P:SetStartLength( StartLength )
					P:SetEndLength( EndLength )
					P:SetRoll( Roll * 36 )
					P:SetRollDelta( RollDelta + RandRoll )
					P:SetAirResistance( AirResistance )
					P:SetBounce( Bounce )
					P:SetGravity( Vector(0, 0, Gravity) )
					P:SetCollide( Collide )
					P:SetLighting( Lighting )
					
					if (Sliding) then
						P:SetCollideCallback( SlideCallback )
					end
					
					if (_3D) then
						if (not Sliding) then
							if (i == 1) then
								P:SetCollideCallback( RemoveCallback )
							else
								P:SetCollideCallback( StickCallback )
							end
						end
						
						if (DoubleSided) and (i == 1) then
							P:SetAngleVelocity( Angle(-AngleVelX, AngleVelY, -AngleVelZ) )
						else
							P:SetAngleVelocity( Angle(AngleVelX, AngleVelY, AngleVelZ) )
						end
						
						P.Align = Align
						P.Stick = Stick
						P.StickLifeTime = StickLifeTime
						P.StickStartSize = StickStartSize
						P.StickEndSize = StickEndSize
						P.StickStartAlpha = StickStartAlpha
						P.StickEndAlpha = StickEndAlpha
					end
				end
			end
			
			self.NextShot = RealTime() + Ent:GetNetworkedFloat("Delay")
		end
		
		return true
	elseif (self.Created < RealTime()) then
		self.Emitter:Finish()
		
		return false
	end
	
	return true
end


function EFFECT:Render()
end



